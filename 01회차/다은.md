## 1장 프로그래밍

### 1.1 프로그래밍이란?

0과 1밖에 알지 못하는 기계가 실행할 정도로 정확하고 상세하게 요구사항을 설명하는 작업. 그 결과물은 코드로 도출된다.  
 **_Computational Thingking_**. 논리적, 수학적 사고가 필요하고, 해결 과제를 작은 단위로 분해하고 패턴화해서 추출하며, 프로그래밍 내에서 사용될 모든 개념은 평가 가능하도록 정의해야 한다.

### 1.2 프로그래밍 언어

기계어를 직접 전달하는 것 대신 사람이 이해할 수 있는 약속된 구문(syntax, 문법)으로 구성된 프로그래밍 언어를 사용해 프로그램을 작성한 후, 그것을 컴퓨터가 이해할 수 있는 기계어로 변환하는 일종의 번역기를 이용한다. 이를 컴파일러(compiler) 혹은 인터프리터(interpreter)라고 한다.

### 1.3 구문과 의미

코드는 해결 방안의 구체적 구현물이며, 프로그래밍 언어의 문법에 부합하는 것은 물론이고 요구사항이 실현(문제가 해결)되어야 의미가 있다.

## 2장 자바스크립트란?

### 2.1 자바스크립트의 탄생

1995년, 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어를 도입하기로 결정한다. by **Brendan Eich**, Netscape communications

### 2.2 자바스크립트의 표준화

파생 버전인 마이크로소프트의 JScript가 등장하고, 기존의 자바스크립트와 표준화되지 못하는 문제가 있었다. (크로스 브라우징 이슈, 자사 브라우저에만 호환되는 기능을 추가)  
컴퓨터 시스템의 표준을 관리하는 비영리 표준화 기구 ECMA 인터내셔널에서 표준화를 진행하여 최종적으로 ECMAScript로 명명된다.

### 2.3 자바스크립트 성장의 역사

초창기엔 서버로부터 전달받은 HTML과 CSS를 단순히 렌더링하는 수준이었다.

1. **Ajax**  
   1999년, 서버와 브라우저가 비동기(asynchronous) 방식으로 데이터를 교환할 수 있는 통신 기능인 Ajax(Asynchronous JavaScript XML)가 XMLHttpRequest 라는 이름으로 등장했다.  
   이전엔 html 코드를 서버로부터 전송받아 웹 페이지 전체를 렌더링 하는 방식으로 동작했는데, Ajax 등장 이후로는 변경해야 하는 부분만 한정적으로 렌더링하는 방식이 가능하게 되어 브라우저에서도 빠른 성능과 부드러운 화면 전환이 가능해졌다.
2. **jQuery**  
   2006년, jQuery의 등장으로 다소 번거롭고 논란이 있던 DOM(Document Object Model)을 더욱 쉽게 제어할 수 있게 되었고 크로스 브라우징 이슈도 어느 정도 해결되었다.
3. **V8 자바스크립트 엔진**  
   2008년, 더욱 빠르게 동작하는 구글의 V8 자바스크립트 엔진의 등장으로 JS는 데스크톱 애플리케이션과 유사한 UX를 제공할 수 있는 언어로 정착하게 되었다. 또한 과거 서버측에서 수행되던 로직들이 대거 클라이언트(브라우저)로 이동해 FE 영역이 주목받는 계기로 작용했다.
4. **Node.js**  
   2009년 라이언 달이 발표한 Node.js는 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경이다. **비동기 I/O**, **단일 스레드(single thread)**, **이벤트 루프** 기반으로 동작함으로써 요청 처리 성능이 좋다.
   데이터를 실시간으로 처리하기 위해 I/O가 빈번히 발생하는 SPA(Single Page Application)에 적합하지만 CPU 사용률이 높은 애플리케이션에는 권장되지 않는다.
5. **SPA 프레임워크**  
   CBD(Component Based Development) 방법론을 기반으로 하는 SPA가 대중화되면서 Angular, React, Vue.js, Svelte 등 다양한 SPA 프레임워크/라이브러리 또한 많은 사용층을 확보하고 있다.

### 2.4 자바스크립트와 ECMAScript

ECMAScript는 자바스크립트의 표준 사양인 ECMA-262를 말하며, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정한다.  
자바스크립트는 기본 뼈대를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, 즉 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, WEb Worker 등을 아우르는 개념이다. Web API는 ECMAScript와는 별도로 W3C(World Wide Web Consortium)에서 별도의 사양으로 관리한다.

### 2.5 자바스크립트의 특징

- 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어
- 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어

#### 컴파일러 언어 vs 인터프리터 언어

| 컴파일러 언어                                                                            | 인터프리터 언어                                                                           |
| :--------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------- |
| 코드가 실행되기 전 단계인 컴파일 타임에 소스코드 전체를 한번에 머신코드로 변환한 후 실행 | 코드가 실행되는 단계인 런타임에 문 단위로 한 줄씩 중간 코드인 바이트코드로 변환한 후 실행 |
| 실행 파일 생성                                                                           | 실행 파일 생성하지 않음                                                                   |
| 컴파일 단계와 실행 단계가 분리되어 있음                                                  | 인터프리트 단계와 실행 단계가 분리되어 있지 않음                                          |
| 실행에 앞서 컴파일은 단 한번 수행됨                                                      | 코드가 실행될 때마다 인터프리트 과정 반복 수행                                            |
| 컴파일과 실행 단계 분리 -> 실행 속도 빠름                                                | 실행 속도 비교적 느림                                                                     |

## 3장 자바스크립트 개발 환경과 실행 방법

### 3.1 자바스크립트 실행 환경

모든 브라우저와 Node.js는 자바스크립트를 해석하고 실행할 수 있는 자바스크립트 엔진을 내장하고 있다. 다만 브라우저는 HTML, CSS, JS를 실행해 웹 페이지를 브라우저 화면에 렌더링하는 것이 주된 목적이지만 Node.js는 브라우저 외부에서 JS 실행 환경을 제공하는 것이 주된 목적이다. 따라서 브라우저와 Node.js 모두 ECMAScript를 실행할 수 있지만 각각 추가로 제공하는 기능은 호환되지 않는다.  
예를 들어, 브라우저 환경의 자바스크립트는 보안상의 이유로 파일 시스템을 제공하지 않고, Node.js의 자바스크립트는 DOM API와 같은 Web API를 사용할 수 없다. (cheerio 같은 DOM 라이브러리를 사용해 HTML 문서를 가공하기도 한다.)

## 4장 변수

### 4.1 변수란 무엇인가? 왜 필요한가?

데이터는 메모리에 저장되고 각 데이터마다 고유한 메모리 주소를 가지는데, 메모리 주소를 통해 직접 값에 접근하는 것은 매우 위험한 일이다.
또한 메모리 주소는 코드가 실행될 때 메모리의 상황에 따라 임의로 결정되기 때문에 실행될 때마다 주소는 달라진다.  
그래서 메모리 공간을 식별하기 위해 붙인 이름, 값의 위치를 가리키는 상징적인 이름인 변수라는 메커니즘을 사용한다. 데이터의 재사용성이 높아지고 더욱 안전해진다.
변수 이름을 사용해 참조를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.

### 4.2 식별자

변수 이름을 식별자(identifier)라고도 한다. 값 자체가 아니라 메모리 주소를 기억해, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.

### 4.3 변수 선언

변수 선언이란 변수를 생성하는 것을 말한다. 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 준비하는 것이다. 변수 선언에 의해 확보된 메모리 공간은 해제(release)되기 전까지 보호되므로 안전하다. `var`, `let`, `const` 키워드를 이용해 변수를 선언한다.

- 선언 단계: 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알린다.
- 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

#### 블록 레벨 스코프 vs 함수 레벨 스코프

`var` 키워드는 여러 단점이 있는데, 그 중 대표적인 것인 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것이다.

- 블록 레벨 스코프 : 모든 코드 블록(함수, if문, for문, while문, try-catch문 등)내에서 선언된 변수는 그 코드 블록 내에서만 유효한 지역 변수이다.
- 함수 레벨 스코프 : 스코프 제한을 함수로만 한다. 함수 내부에서 선언된 변수는 지역 변수이나, 외부에서 선언된 변수는 전역 변수이다.

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다. 이 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.  
변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(Variable Hoisting)이라 한다. 모든 선언문은 런타임 이전 단계에서 먼저 실행된다.

### 4.5 값의 할당

```javascript
var score = 80; // 변수 선언 & 값 할당
```

변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 여전히 2개의 문이다. 변수 선언은 런타임 이전에 먼저 실행되고(호이스팅), 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

```javascript
console.log(score); // undefined

score = 80; // 값의 할당
var score; // 변수 선언

console.log(score); // 80
```

1. 실행 전 score 변수 호이스팅 [(참고)](#44-변수-선언의-실행-시점과-변수-호이스팅)
2. 첫번째 콘솔로그
3. score에 80 할당
4. 두번째 콘솔로그

### 4.6 값의 재할당

변수에 값을 할당할 때는 이전 값이 저장되어 있던 메모리 공간을 지우고 그 자리에 새로운 값을 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장한다는 점에 주의하자.  
 -> 이전 값은 더 이상 필요하지 않고, 이러한 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 단 해제 시점은 예측할 수 없다.

#### 언매니지드 언어 vs 매니지드 언어

C언어 같은 언매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제할 수 있다. 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만 치명적 오류를 생산할 가능성도 있다.  
자바스크립트 같은 매니지드 언어는 메모리 관리 기능을 언어 차원에서 담당해 개발자가 관여할 수 없다. 일정한 생산성을 확보할 수 있다는 장점이 있지만 성능 면에서 어느 정도의 손실은 감수할 수밖에 없다.

### 4.7 식별자 네이밍 규칙

- 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)로 구성
- 숫자로 시작하는 것은 허용되지 않음
- 예약어는 식별자로 사용할 수 없음
- 알파벳 외의 유니코드 문자(한글, 일본어 등)은 권장되지 않음
- 대소문자를 구별함
- 변수나 함수는 카멜 케이스를, 생성자 함수나 클래스는 파스칼 케이스를 사용

#### 네이밍 컨벤션

- 카멜 케이스 `camelCase`
- 스네이크 케이스 `snake_case`
- 파스칼 케이스 `PascalCase`
- 헝가리언 케이스 `typeHungarianCase`

## 5장 표현식과 문

### 5.1 값

표현식이 평가되어 생성된 결과. 평가는 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

### 5.2 리터럴

사람이 이해할 수 있는 문자(숫자, 알파벳 등) 또는 미리 약속된 기호('', {}, // 등)을 사용해 값을 생성하는 표기법

### 5.3 표현식

값으로 평가될 수 있는 문. 리터럴도 표현식이고, 변수 식별자를 참조해도 표현식이다. 값으로 평가될 수 있는 문은 모두 표현식이다.

### 5.4 문

프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다. 문은 여러 토큰으로 구성되는데 토큰이란 문법적 의미를 가지며 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.

```javascript
var sum = 1 + 2;
```

이 하나의 문에서 `var`, `sum`, `=`, `1`, `+`, `2`은 각각 하나의 토큰이다.

### 5.5 세미콜론과 세미콜론 자동 삽입 기능(ASI)

자바스크립트는 기본적으로 세미콜론이 자동적으로 삽입되지만 예외는 당연히 있기 때문에 세미콜론을 붙이는 것이 권장된다.

### 5.6 표현식인 문과 표현식이 아닌 문

이 둘을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.

```javascript
var foo = var x; // SyntaxError: Unexpected token var
// 표현식이 아닌 문인 선언문은 값처럼 사용할 수 없다.
```

크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하는데 이를 완료 값이라고 한다. 표현식인 문을 실행하면 평가된 값을 반환한다.
