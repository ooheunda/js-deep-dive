# 6. 데이터 타입

![image](https://github.com/ooheunda/how-to-enjoy/assets/154396245/d2adb6e0-ec62-4974-b5c1-f4e63a099fff)
(출처 :  https://workatit.tistory.com/88 )
사진에는 기본형이라고 나와있지만, 책에는 원시타입으로 나와있다. 
      
## 숫자타입
- 자바스크립트는 하나의 숫자타입만 존재한다.
- 모든 수를 실수로 처리한다.

## 문자열타입
- 자바스크립트의 문자열은 변경불가능한 값이다. 생성되면 병경할 수 없다.
- "",'',`` 기호 안에 넣는 방식
- 줄바꿈, 탭, 들여쓰기등 공백을 표현하려면 이스케이프 시퀀스를 사용한다.

## 템플릿 리터럴
- `` 백틱을 사용해 표현한다.
- 일반 문쟈열과 달리 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 적용된다.
- 표현식 삽입시 ${}로 표현식을 감싼다. 표현식이 문자열이 아니더라도 문자열로 강제 변환되어 삽입된다.(표현식은 템플릿 리터럴내에서만 유효)

## 불리언 타입
- 불리언 타입의 값은 true, false 두가지밖에 없다.

## undefined
- undefined타입의 값은 undefined가 유일하다.

## null
- null타입의 값은 null이 유일하다.
- null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다.

## 심벌타입
- 심벌은 ES6에서 추가된 타입으로, 다른값과 중복되지 않는 값이다.
- 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티키를 만들기위해 사용한다.
- 심벌은 Symbol함수를 호출해 생성한다.

## 객체 타입
- 위에 6가지이외는 모두 객체 타입이다.(함수, 객체, 배열등)

## 데이터 타입의 필요성 
- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

## 동적타이핑
- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정되고, 재할당에 의해 언제든지 타입이 변할 수 있다.
- 동적타입 언어는 유연성은 높지만 신뢰성은 떨어진다.
- 동적 타입 언어에서 변수를 사용할 때 주의사항
  1. 변수는 꼭 필요한 경우에만 최소한으로 사용.
  2. 변수의 스코프를 최대한 좁게 만들기.
  3. 변수보다 상수를 사용해 값의 변경을 억제
  4. 모든 식별자는 존재 이유를 파악할 수 있는 적절한 이름으로 짓기.  

  
---

  
# 7. 연산자
-연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다.

## 산술 연산자
- 산술 연산자는 수학적 계산을 수행
  1. 이항 산술 연산자(+, -, *, /, %)
  2. 단항 산술 연산자(++, --, +, -)
     - ++/-- 연산자는 피연산자의 값을 변경하는 부수효과가 있다.
     - ++/-- 연산자의 위치에 의미가 있다. 피연산자 앞에 있으면 값을 증가/감소시킨후 다른 연산을 수행한다. 뒤에 있으면 다른 연산을 수행한 후. 피연산자의 값을 증가/감소시킨다.
     - 숫자 타입이 아닌 피연산자에 +/- 단항연산자를 사용하면 피연산자를 숫자타입으로 변환하여 반환한다. - 단항연산자는 부호를 반전한 값 반환한다.
  3. 문자열 연결 연산자(+)
     - +는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

## 할당연산자(=, +=, -=, *=, /=, %=)
- 여러 변수에 동일한 값을 연쇄 할당할 수도 있다.

## 비교연산자
- 동등 비교 (==) 연산자는 좌, 우항의 피연산자가 타입은 다르더라도 같은 값이면 true를 반환한다.
- 일치 비교 (===) 연산자는 좌, 우항의 피연산자가 타입도 같고 값도 같은 경우에 true를 반환한다.
- 대소관계 비교연산자 (>, <, >=, <=)

## 삼항 조건 연산자
- 표현식
  조건식 ? (true이면 반환할 값) : (false이면 반환할 값)
- 삼항연산자는 표현식인 문이다.

## 논리 연산자(||, &&, !)

## 쉼표 연산자 (,)
```
var x, y, z;
x = 1, y = 2, z = 3;  // 3
```
위의 예제는 마지막 피연산자인 z의 값 3을 반환했지만, 반환한 값보다도, 
```
var x;
var x;
var x;
x = 1;
y = 2;
z = 3;
```
을 묶어서 한번에 선언하고 할당한 것이다.

## 그룹연산자(())

## typeof 연산자
- 버그1. typeof로 null값을 연산해보면 null이 아닌 object라고 나온다. 버그다.
- 버그2. 선언하지 않은 식별자를 typeof로 연산해보면 ReferenceError가 발생하지 않고 undefined를 반환한다. 버그다

## 지수 연산자(**)
- 3**7 = 3의 7제곱
- Math.pow(3, 7)메서드랑 동일한 역할을 하지마느 더 가독성이 좋다.
- 지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.

---

# 8. 제어문
- 제어문은 조건에 따라 코드  블록을 실행하거나 반복실행할 때 사용한다.

## 블록문 {}
- 블록문은 0개 이상의 문을 중괄호로 묶은 것
- 주의사항! 블록문의 끝에는 세미콜론을 붙이지 않는다!

## 조건문 
- 조건문은 주어진 조건식의 평가 결과에 따라 코드믈록(블록문)의 실행을 결정한다.
  #### if ...else문
  - 형태
    ```
    if (조건식) {
    조건식이 true일 때 실행할 로직1
    } else {
    조건식이 false라면 실행할 로직2
    }
    ```
  - if문과 else문은 2번 이상 사용할 수 없지만 else if문은 여러 번 사용할 수 있다.
  #### switch문
  - 형태
    ```
    switch (표현식) {
      case 표현식1:
        switch 문의 표현식과 표현식1이 일치하면 실행될 문;
        break;
      case 표현식2:
        switch 문의 표현식과 표현식2이 일치하면 실행될 문;
        break;
      default:
        switch 문의 표현식과 일치하는 case문이 없을 때 실행될 문;
    }
    ```
  - swith문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행 흐름을 옮긴다.
  - switch문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.
  - break;가 없으면 일치하는 case가 있어도 폴스루(fall through)가 발생한 default값 결과가 나온다.

## 반복문 
- 반복문은 조건식의 평가 결과가 참인 경우 코드블록을 실행한다. 그 후 조건식을 다시 평가하여 조건식이 거짓일 때까지 반복해서 실행한다.
  #### for문
  - 형태
    ```
    for (변수 선언문 또는 할당문; 조건식; 증감식) {
      조건식이 참인 경우 반복 실행될 문;
    }
    ```

  #### while문
  - for문은 반복 횟수가 명확할 때 주로 사용하고, while문은 반복횟수가 불명확할 때 주로 사용한다.
  - 형태
    ```
    while (조건식) {
      조건식이 참인 경우 반복 실행될 문;
      증감식;
    }
    ```
  #### do...while문
  - do...while문은 코드블록을 먼저 실행하고 조건식을 평가한다. 코드블록은 무조건 한번이상 실행된다.
  - 형태
    ```
    do {
      조건식이 참인 경우 반복 실행될 문;
      증감식;
    } while (조건식);
    ```
## break문
- 레이블 문, 반복문, swith문이 break문을 만나면 그지점에서 실행을 멈추고, 코드블록을 탈출한다.
- 형태
  ```
   for (변수 선언문 또는 할당문; 조건식; 증감식) {
      if (조건식) {
        조건식이 참이면 실행될 문;
        break;
      }
   }
  ```

## continue문
- continue문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.
- break문처럼 반복문을 탈출하지는 않는다.
- 형태
  ```
  for (변수 선언문 또는 할당문; 조건식; 증감식) {
    if (조건식) continue;
    조건식이 거짓이면 실행될 문;
  }
  ```

---
---
(ver. 2)
# 6장 데이터 타입

자바스크립트는 7개의 데이터 타입을 제공한다. 숫자타입, 문자열타입, 불리언타입 ,undefined, null, 심벌타입이 원시타입으로 묶이는 6가지 타입이고, 객체타입(객체, 함수, 배열 등)을 한가지로 쳐서 7개다.

## 6.1 숫자타입

C나 자바와 다르게, 자바스크립트는 하나의 숫자타입만 존재한다. **자바스크립트는 모든 수를 실수로 처리**하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.

자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터타입은 제공하지 않기 때문에 이들의 값을 참조하면 10진수로 해석된다. 

숫자타입은 Infinity, -Infinity, NaN(산수연산불가)도 표현할 수 있다.

## 6.2 문자열 타입

문자열은 텍스트 데이터를 나타내는데 사용한다. 

문자열은 ‘’작은 따옴표, “”큰따옴표, ``백틱으로 텍스트를 감싼 것이다. 이는 키워드나 식별자 같은 토큰과 문자열을 구분하기 위해서이다.

**자바스크립트의 문자열은** 원시타입이며 **변경불가능한 값**이다.

## 6.3 템플릿 리터럴

템플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공한다.

템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다.

### 6.3.1 멀티라인 문자열

일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다. 그래서 일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 백슬래시(\)로 시작하는 **이스케이프 시퀀스**를 사용해야한다.

이스케이프 시퀸스의 예시: \n(개행. 다음행으로 이동), \t(가로 Tab=들여쓰기) , \’(작은따옴표), \”(큰따옴표), \\(백슬래시)

그런데 **템플릿 시터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용된다.** 

### 6.3.2 표현식 삽입

문자열은 문자열연산자 +를 사용해 연결할 수 있다. +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작한다.

하지만 템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열을 삽입할 수 있다. 표현식을 삽입하려면 **${}으로 삽입하려는 표현식을 감싸서 템플릿 리터럴내에 삽입하고자 하는 위치에 넣는다.** 이때 표현식의 평가 결과가 문자가 아니더라도 문자열로 타입이 강제로 변환되어 삽입된다. 

```jsx
var first = 'eock-chuck';
var last = 'kim';

var introduce = `my name is ${first} ${last}`;
```

템플릿 리터럴이 아닌 일반 문자열에서의 표현식 삽입은 그냥 그대로 문자열로 취급된다.

## 6.4 불리언 타입

불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다.

## 6.5 undefined 타입

undefined타입의 값은 undefined가 유일하다.

undefined 값은 자바스크립트 엔진이 변수를 선언하면서 초기화할 때 사용하는 값이다. 개발자가 의도적으로 변수에 undefined를 할당하는 것은 undefined의 본래 취지와 어긋나고 혼란을 줄 수 있으므로 자제해야 한다.

## 6.6 null타입

null 타입의 값은 null이 유일하다. 

null은 개발자가 변수에 값이 없다는 것을 의도적으로 명시하고자 할 때 사용한다. 

함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다. 예를 들자면 HTML요소를 검색해 반환하는 document.querySelector 메서드는 조건에 부합하는 HTML요소를 검색할 수 없는 경우 에러대신 null을 반환한다.

## 6.7 심벌 타입

심벌(symbol)은 **변경불가능한** 원시타입의 값이다. **다른 값과 중복되지 않는 유일무이한 값**이다. 따라서, 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

심벌은 다른 원시 값과는 다르게 **Symbol 함수를 호출해 생성**한다. 이때 생성된 심벌값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.

## 6.8 객체 타입

자바스크립트의 데이터 타입은 크게 원시타입과 객체타입으로 분류하는데, 이는 객체타입과 원시타입이 근본적으로 너무 다르기 때문이다. 

자바스크립트는 객체기반의 언어이며, **자바스크립트를 이루고 있는 거의 모든 것이 객체다.** 원시타입 6가지 이외의 값은 모두 객체타입이다.

## 6.9 데이터 타입의 필요성

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

자바스크립트 엔진은 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보한다. 즉, 변수에 할당되는 **값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정**된다.

예를 들어, ECMAScript사양에서 숫자 타입은 배정밀도 64비트 부동소수점 형식을 사용한다고 하는데, 이 형식은 8바이트로 숫자를 표현하므로, 숫자 타입이 할당된 변수를 위해 자바스크립트 엔진이 확보하는 메모리 공간은 8바이트이다. 

**값을 참조할 때도, 변수의 데이터 타입에 따라 읽어들여야 할 메모리 공간의 크기를 결정**한다. 읽어들여야 할 메모리 공간의 크기를 알아야 정상적으로 값을 참조할 수 있다. 

### 6.9.2 데이터 타입에 의한 값의 해석

모든 값은 데이터 타입을 가지며 메모리에 (숫자타입이 아니어도)2진수의 나열로 저장된다. **자바스크립트 엔진은 메모리에 저장된 2진수를 데이터 타입을 파악하여 다르게 읽는다.** (0100 0001은 숫자이면 65지만 문자열일 때는 ‘A’로 읽는다.)

## 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

자바스크립트는 동적 타입 언어로, 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다. 키워드(var, let, const)를 사용해 변수를 선언할 뿐이다. 

정적 타입 언어는 미리 선언한 데이터 타입의 값만 선언할 수 있다면, 자바스크립트는 어떤 데이터 값이라도 자유롭게 할당할 수 있다.

typeof 연산자로 변수를 연산하면 변수의 데이터 타입을 반환한다.

**자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 동적으로 변할 수 있다.**

이런 특징을 가진 언어를 정적 타입 언어와 구별하기 위해 **동적 타입 언어**라고 한다.

### 6.10.2 동적 타입 언어와 변수

동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 그래서 변수 값은 언제든지 타입이 변경할 수 있고, 자바스크립트 엔진에 의해 암묵적으로 자동 변환되기도 한다. 

즉, **동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.**

그래서 변수를 사용할 때 주의할 사항은 다음과 같다.

- 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다. 변수의 개수가 많으면 많을 수록 오류가 발생할 확률도 높아진다.
- 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다. 전역 변수는 최대한 사용하지 않도록 한다.
- 변수보다는 상수를 사용해 값의 변경을 억제하자.
- 모든 식별자(변수, 함수, 클래스)는 존재 이유를 파악할 수 있는 적절한 이름으로 지어야 한다.

# 7장 연산자

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자라고 한다. 

피연산자와 연산자 표현식은 값으로 평가될 수 잇는 표현식이어야 한다.

피연산자(ex. 332)가 값이라는 명사라면, 연산자(ex. +)는 ‘피연산자를 연산하여 값을 도출한다’는 동사의 역할이다.

## 7.1 산술 연산자

산술 연산자는 피연산자를 대상으로 **수학적 계산을 수행해 새로운 숫자 값을 만든다.**

산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.

### 7.1.1 이항 산술 연산자

이항 산술 연산자는 2개의 피 연산자를 산술 연산하여 숫자 값을 만든다. 

이항 산술 연산자의 종류 → **+(덧셈), -(뺄셈), *(곱셈), /(나눗셈), %(나머지)**

### 7.1.2 단항 산술 연산자

단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.

단항 산술 연산자의 종류 → **++(증가), --(감소), +(효과없음), -(양수를 음수로, 음수를 양수로 반전한다.)**

**증가/감소(++/--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다. 피연산자의 값을 변경하는 암묵적 할당이 이루어진다.** 

**증가/감소 연산자(++/--)가  피연산자의 앞에 위치하면 피연산자의 값을 먼저 증가/감소시킨 후, 다른 연산을 수행한다. 피연산자의 뒤에 위치하면 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.**

숫자타입이 아닌 피연산자에 ‘+’ 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 피연산자를 변경하는 부수 효과는 없다.

‘-’  단항 연산자는 피연산자가 음수라면 양수로, 양수라면 음수로 반전한 값을 반환하고, ‘+’ 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 역시 마찬가지로 피연산자를 변경하지는 않는다.

### 7.1.3 문자열 연결 연산자

**‘+’연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결연산자로 동작한다.** 그 이외에는 산술 연산자로 동작한다.

앞선 단항연산자’+’,’-’와 문자열 연결 연산자 ‘+’는 모두 자바스크립트엔진이 암묵적으로 타입을 변환하여 연산을 수행하는 연산자이다. 이를 **암묵적 타입변환/타입 강제 변환** 이라고 한다. 

## 7.2 할당 연산자

할당 연산자는 우항에 있는 피연산자의 평과 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수효과가 있다.

할당연산자 종류 → **=, +=, -=, *=, /=, %=**(ex. x -= 5로 표현하지만 x = x - 5 이걸 함축한 표현이다.)

**할당문은 값으로 평가되는 표현식인 문**으로서 할당된 값으로 평가된다.

## 7.3 비교 연산자

비교 연산자는 좌항이나 우항의 피연산자를 비겨한 다음 그 결과를 불리언 값으로 반환한다.

### 7.3.1 동등/일치 비교 연산자

동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값으로 반환한다. 

**동등 비교 연산자(==)는** 좌항과 우항의 피연산자를 비교 할 때 먼저 암묵적 타입 변환을 통해 **타입을 일치시킨 후 같은 값인지 비교한다.** 그래서 사용시에 결과를 예측하기 어렵고 실수하기 쉽다.

**일치 비교 연산자(===)는** 좌항과 우항의 **피연산자가 타입 같고 값도 같은 경우에 한하여 true를 반환한다.** 

단, NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자타입 값이 NaN인지 조사하려면 빌트인함수 **Number.isNaN** 을 사용한다.

숫자 0도 자바스크립트에는 양의 0(0)과 음의 0(-0)이 있는데, 이들을 비교하면 같은 값으로 친다. (동등/일치연산자 모두 true 반환)

ES6에서는 위와 같은 예외상황을 위해 [Object.is](http://Object.is) 메서드가 생겼다. 이는 NaN/0/-0의 정확한 비교결과를 반환한다. 이외에는 일치 비교 연산자(===)와 동일하게 동작한다.

**부동등 비교 연산자(!=)**와 **불일치 비교연산자(!==)**는 각각 ==와 ===의 반대 개념이다.

### 7.3.2 대소 관계 비교 연산자

대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다. 

대소 관계 비교 연산자 종류 → **>, <, >=, <=**

## 7.4 삼항 조건 연산자

삼항 조건 연산자는 조건 식의 평가 결과에 따라 반환할 값을 결정한다.

표현식의 공식(?)은 다음과 같다. → **조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값**

삼항 조건 연산자 표현식은 조건문이다. if…else문을 사용해도 유사하게 처리할 수 있다. 그러나 중요한 차이점이 있다. 삼항 조건 연산자 표현식은 값처럼 사용할 수 있지만 if…else문은 값처럼 사용할 수 없다. 즉, **삼항 조건 연산자는 표현식인 문이고, if…else문은 표현식이 아닌 문이다.**

## 7.5  논리 연산자

논리 연산자는 우항과 좌항의 피연산자를 논리 연산한다.

논리 연산자의 종류 ⇒ **||(논리합= OR), &&(논리곱=AND), !(부정=NOT)**

**부정 연산자(!)는 항상 불리언 값을 반환**한다. 만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다.

논리합(||)/논리곱(&&)연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

## 7.6 쉼표 연산자

쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과만 반환한다. (여기서 반환은 값을 가지는 것만 의미함. 로그 찍은 것처럼 값이 print되는 것은 아님.) 

```jsx
var x, y, z; //=> 표현식이 아닌 문이라서 값이 나와도 . 
//마지막줄을 선언문 나열으로 끝내봤는데, 마지막 줄은 싹 무시하고 표현식중 마지막 값만 반환했음.

x = 1, y =2, z = 3 //3 ->만약 아래줄에 다른 쉼표연산자를 이용한 표현식이 더 있으면 무조건 마지막 값만 반환함.
```

```jsx
var x, y, z;
x = 1, y = 2, z = 3;
var o;
o = 4;//4 =>자바스크립트는 원래 표현식이 나오면 그 결과값을 반환한다. 근데 늘 마지막 값만 반환하는 듯.
```

```jsx
var x, y, z;
x = 1, y = 2, z = 3;
var o = 4, w = 5;//3 => 마지막 줄을 선언+할당문으로 쓰니까 오히려 무시해버림;; 선언+할당문은 표현식아닌가봐
//근데 저 결과가 제대로 반영은 되어있는 듯 o + x 를 마지막에 썼더니 5를 제대로 반환함.
```

아직 해결되지 않은 의문
- 마지막줄에 쓰더라도 나열식으로 쓴 선언문의 값이 안나오는 이유>표현식이 아닌 문이라서? 
- 선언+할당문은 값이 나오지 않나? 표현식으로 안 쳐서 무시했나?

## 7.7 그룹 연산자

**소괄호()로 피연산자를 감싸는 그룹 연산자**는 자신의 피연산자인 표현식을 가장 먼저 평가한다.(=사칙연산에서 쓰는 괄호와 같음)

## 7.8 typeof 연산자

typeof연산자는 피연산자의 데이터 타입을 문자열로 반환한다. **typeof연산자는 string, number, boolean, undefined, symbol, object, function중 하나를 반환한다.** 

typeof 연산자가 null을 반환하는 경우는 없고, null의 타입을 확인해보면 object라고 나온다.(이건 버그임) 따라서, 값이 null타입인지 확인할 때는 일치 연산자(===)를 활용한다.

선언하지 않은 식별자를 typeof 연산자로 확인해보면 RefferenceError가 발생하지 않고 undefined를 반환한다. 이것도 버그인듯

## 7.9 지수 연산자

ES7에서 도입된 지수 연산자(**)는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭제곱하여 숫자 값을 반환한다. (ex. 2 ** 3)

**지수 연산자가 도입되기 이전에는 Math.paw(밑, 지수)메서드를 사용했다.**

음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어서 사용해야 한다.

지수 연산자도 할당 연산자와 함께 사용할 수 있다. (**=)

**지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.**

## 7.10 그 외의 연산자

?., ??, delete, new, instanceof, in 같은 연산자들이 있는데, 이후 책에서 다룰 예정

## 7.11 연산자의 부수효과

대부분의 연산자는 다른 코드에 영향을 주지 않는다. 하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다. **부수효과가 있는 연산자는 할당연산자(=), 증가/감소 연산자(++,--), delete연산자다.** 

## 7.12 연산자의 우선순위

여러개의 연산자로 이루어진 문이 실행될 때, 연산자가 실행되는 순서가 있다. 연산자의 우선순위는 책(91~92쪽)에 있는 표를 참고하면 되지만, 가장 중요한 건 **우선순위 1순위가 그룹 연산자()**라는 것이다.

## 7.13 연산자 결합 순서

연산자의 결합 순서란 연산자의 좌항, 우항 중 어느쪽 부터 평가를 수행할 것인지를 말한다.

- 좌항→우항: 사칙연산(+, -, *, /) 연산자, 비교연산자(<, <=, >, >=), 논리합(||), 논리곱(&&), 괄호연산자 등
- 우항→좌항: 할당연산자(=, +=, -=, *=, /= …), 증가/감소 연산자(++, --), typeof 연산자 등

# 8장 제어문

제어문은 조건에 따라 코드 블록을 실행(조건문)하거나, 반복 실행(반복문)할 때 사용한다.

## 8.1 블록문

**블록문은 0개 이상의 문을 중괄호로 묶은 것**으로 ‘코드블록’이나 ‘블록’이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다.

**블록문의 끝에는 세미콜론을 붙이지 않는다.**

## 8.2 조건문

조건문은 주어진 조건식의 평가 결과에 따라 블록의 실행을 결정한다. 조건식은 불리언 값으로 표현될 수 있는 표현식이다.

### 8.2.1 if … else문

if…else문은 조건식(불리언으로 평가될 수 있는 표현식이어야 한다.)의 평가 결과에 따라 실행할 블록을 결정한다. **조건식 평가가 true일 경우, if문의 블록을 실행하고, false일 경우, else문의 블록을 실행한다.**

조건식을 추가하여 조건에 따라 실행될 코드 블록을 늘리고 싶으면 **else if 문**을 사용하면 된다. if와 else문은 2번 이상 사용할 수 없지만 else if문은 여러 번 사용할 수 있다.

### 8.2.2 switch문

switch문은 주어진 표현식(값)을 평가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행흐름을 옮긴다.

switch문 공식(?)

```jsx
switch (표현식) {
	case 표현식1: 
		주어진 표현식과 표현식1이 일치하면 실행할 문;
		break;
	case 표현식2: 
		주어진 표현식과 표현식2이 일치하면 실행할 문;
		break;
	case 표현식3: 
		주어진 표현식과 표현식3이 일치하면 실행할 문;
		break;
	default: 주어진 표현식과 일치하는 경우가 없을 때 실행될 문
}
```

default문은 옵션이라서 사용할 수도 있고, 안 해도 된다. 가장 마지막에 써야한다.

switch문의 표현식은 불리언값보다는 문자열이나 숫자 값인 경우가 많다. **즉, if…else문은 논리적 참, 거짓으로 실행할 블록을 결정한다면,  switch문은 다양한 상황(case)에 따라 실행할 블록을 결정할 때 사용한다.**

case문의 마지막에 break문을 사용하지 않으면, 표현식에 해당하는 case문을 실행하더라도, 이후에 있는 case문을 마지막까지 실행한다.(이때부터는 표현식이랑 일치하는지를 고려하지 않고 모두 실행한다.) 이걸 **폴스루(fall through)**라고 한다.

## 8.3 반복문

반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다.

### 8.3.1 for문

for문의 공식(?)

```jsx
for (변수 선언문이나 할당문; 조건식; 증감식) {
	조건식이 참인 경우 반복 실행될 문;
}
```

for문 내에 for문을 중첩해 사용할 수도 있다. 이를 중첩 for문이라고 한다.

### 8.3.2 while문

**for문은 반복횟수가 명확할때 주로 사용하는데, while문은 반복횟수가 불명확할 때 사용한다.** 

while문은 조건식의 평가결과가 불리언 값이어야 하는데, 만약 아니라면 불리언 값으로 강제 변환하여 논리적 참, 거짓을 구분한다.

while문의 공식(?)

```jsx
while (조건식) {
	조건식이 참이면 반복실행될 문;
}
```

조건식의 결과가 참이면 무한루프 되기 때문에, if문과 break문으로 탈출조건을 만들거나 반복실행문에 증감식을  적절하게 넣어줘야 한다.

### 8.3.3 do…while문

**do…while문은** while문과 비슷한 방식으로 작동하지만 약간 다르다. **코드 블록을 먼저 실행하고 조건식을 평가한다.** 따라서 코드블럭은 무조건 한 번 이상 실행된다.

```jsx
do {
	조건식이 참이면 반복실행될 문
} while (조건식)
```

## 8.4 break문

**break문은 레이블문, 반복문 또는 switch문의 코드블록을 탈출할 때 쓴다.** 이 코드블록들 이외에 break문을 사용하면 syntaxError가 발생한다.

레이블문은 코드블럭인데, 식별자(이름)가 붙은 문을 말한다. (label문인 듯.) 중첩된 for문의 외부 for문에 식별자를 붙여서 내부에서 break문과 만나 외부 for문까지 한번에 탈출하고 싶을 때 사용한다.

 

## 8.5 continue문

**continue문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.** break문처럼 반복문을 탈출하지는 않는다.
