## 의문점 호이스팅
1. 호이스팅은 그냥 유의해야 하는 점에만 국한되어 있는건지, 언젠가 호이스팅을 활용하여 개발하는 경우가 생기는지?

# 1장 프로그래밍

- **1.1 프로그래밍이란?**  
  0과 1밖에 알지 못하는 기계가 실행할 정도로 정확하고 상세하게 요구사항을 설명하는 작업. 그 결과물은 코드로 도출된다.  
  ***Computational Thingking***. 논리적, 수학적 사고가 필요하고, 해결 과제를 작은 단위로 분해하고 패턴화해서 추출하며, 프로그래밍 내에서 사용될 모든 개념은 평가 가능하도록 정의해야 한다.

- **1.2 프로그래밍 언어**  
  기계어(Machine code)를 직접 전달하는 것 대신 사람이 이해할 수 있는 약속된 구문(syntax, 문법)으로 구성된 프로그래밍 언어(Programming Language)를 사용해 프로그램을 작성한 후,
  그것을 컴퓨터가 이해할 수 있는 기계어로 변환하는 일종의 번역기를 이용한다. 이를 컴파일러(compiler) 혹은 인터프리터(interpreter)라고 한다.
  
- **1.3 구문과 의미**


# 2장 자바스크립트란?

- **2.1 자바스크립트의 탄생**  
  1995년, 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어를 도입하기로 결정한다. by Brendan Eich, Netscape communications
  
- **2.2 자바스크립트의 표준화**  
  파생 버전인 마이크로소프트의 JScript로 마소랑 넷스케이프랑 기능 경쟁하다 표준화 신청함. (참고-크로스 브라우징 이슈)  
  컴퓨터 시스템의 표준을 관리하는 비영리 표준화 기구 ECMA 인터내셔널에서 표준화를 진행하여 최종적으로 ECMAScript로 명명된다. 많이 들어온 ES6는 ECMAScript의 버전6 였다.
  
- **2.3 자바스크립트 성장의 역사**  
  초창기엔 서버로부터 전달받은 HTML과 CSS를 단순히 렌더링 하는 수준이었다.  
  1. **Ajax**  
     1999년, 서버와 브라우저가 비동기(asynchronous) 방식으로 데이터를 교환할 수 있는 통신 기능인 Ajax(Asynchronous JavaScript XML)가 XMLHttpRequest 라는 이름으로 등장했다.  
     이전엔 html 코드를 서버로부터 전송받아 웹 페이지 전체를 렌더링 하는 방식으로 동작했는데, Ajax 등장 이후로는 변경해야 하는 부분만 한정적으로 렌더링하는 방식이 가능하게 되어 브라우저에서도 빠른 성능과 부드러운 화면 전환이 가능해졌다.
  2. **jQuery**  
     2006년, jQuery의 등장으로 다소 번거롭고 논란이 있던 DOM(Document Object Model)을 더욱 쉽게 제어할 수 있게 되었고 크로스 브라우징 이슈도 어느 정도 해결되었다.
  3. **V8 자바스크립트 엔진**  
     2008년, 더욱 빠르게 동작하는 구글의 V8 자바스크립트 엔진의 등장으로 JS는 데스크톱 애플리케이션과 유사한 UX를 제공할 수 있는 언어로 정착하게 되었다. 또한 과거 서버측에서 수행되던 로직들이 대거 클라이언트(브라우저)로 이동해 FE 영역이 주목받는 계기로 작용했다.
  4. **Node.js**  
     2009년 라이언 달이 발표한 Node.js는 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경(runtime environment)이다. **비동기 I/O**, **단일 스레드(single thread)**, **이벤트 루프** 기반으로 동작함으로써 request 처리 성능이 좋다.
     데이터를 실시간으로 처리하기 위해 I/O가 빈번히 발생하는 SPA(Single Page Application)에 적합하지만 CPU 사용률이 높은 애플리케이션에는 권장되지 않는다.
  5. **SPA 프레임워크**  
     CBD(Component Based Development) 방법론을 기반으로 하는 SPA가 대중화되면서 Angular, React, Vue.js, Svelte 등 다양한 SPA 프레임워크/라이브러리 또한 많은 사용층을 확보하고 있다.
     
- **2.4 자바스크립트와 ECMAScript**  
  ECMAScript는 자바스크립트의 표준 사양인 ECMA-262를 말하며, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정한다.
  자바스크립트는 기본 뼈대를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, 즉 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, WEb Worker 등을 아우르는 개념이다.

- **2.5 자바스크립트의 특징**
  - 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어(interpreter language)
  - 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어  

|컴파일러 언어|인터프리터 언어|
|:---|:---|
|코드가 실행되기 전 단계인 컴파일 타임에 소스코드 전체를 한번에 머신코드로 변환한 후 실행|코드가 실행되는 단계인 런타임에 문 단위로 한 줄씩 중간 코드인 바이트코드로 변환한 후 실행|
|실행 파일 생성|실행 파일 생성하지 않음|
|컴파일 단계와 실행 단계가 분리되어 있음|인터프리트 단계와 실행 단계가 분리되어 있지 않음|
|실행에 앞서 컴파일은 단 한번 수행됨|코드가 실행될 때마다 인터프리트 과정 반복 수행|
|컴파일과 실행 단계 분리->실행 속도 빠름|실행 속도 비교적 느림|

- **2.6 ES6 브라우저 지원 현황**


# 4장 변수

- **4.1 변수란 무엇인가? 왜 필요한가?**  
  데이터는 메모리에 저장되고 각 데이터마다 고유한 메모리 주소를 가지는데, 메모리 주소를 통해 직접 값에 접근하는 것은 매우 위험한 일이다.
  또한 메모리 주소는 코드가 실행될 때 메모리의 상황에 따라 임의로 결정되기 때문에 주소를 사용해 직접 접근하는 것은 올바른 방법이 아니다.
  그래서 메모리 공간을 식별하기 위해 붙인 이름, 값의 위치를 가리키는 상징적인 이름인 변수라는 메커니즘을 사용한다. 데이터의 재사용성이 높아지고 더욱 안전해진다.
  **변수 이름을 사용해 참조를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.**
  
- **4.2 식별자**
  메모리 주소에 붙인 이름. 변수 이름(변수명)과 동일하다.
  
- **4.3 변수 선언**  
  `var`, `let`, `const` 키워드를 이용해 변수를 선언한다. `var` 키워드는 여러 단점이 있는데, 그 중 대표적인 것인 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것이다.  
  - 블록 레벨 스코프 : 모든 코드 블록(함수, if문, for문, while문, try-catch문 등)내에서 선언된 변수는 그 코드 블록 내에서만 유효한 지역 변수이다.
  - 함수 레벨 스코프 : 블록 레벨 스코프에서 제한을 함수로만 한다. 함수 내부에서 선언된 변수는 지역 변수이나, 외부에서 선언된 변수는 전역 변수이다.
    
- **4.4 변수 선언의 실행 시점과 변수 호이스팅**  
  소스코드의 평가 과정: 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다. 이 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.  
  변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(Variable Hoisting)이라 한다. 모든 선언문은 런타임 이전 단계에서 먼저 실행된다.

- **4.5 값의 할당**  
  ```
  var score = 80; //변수 선언 & 값 할당
  ```
  변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 여전히 2개의 문이다. 변수 선언은 런타임 이전에 먼저 실행되지만(호이스팅), 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.
  ```
  console.log(score) //undefined
  
  score = 80; //값의 할당
  var score; //변수 선언

  console.log(score) //80
  ```
  실행 전 score 변수 호이스팅 ➡️ 런타임) 첫번째 콘솔로그 ➡️ 런타임) score에 80 할당 ➡️ 런타임) 두번째 콘솔로그

- **4.6 값의 재할당**  
  변수에 값을 할당할 때는 이전 값이 저장되어 있던 메모리 공간을 지우고 그 자리에 새로운 값을 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장한다는 점에 주의하자.  
  -> 이전 값은 더 이상 필요하지 않고, 이러한 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 단 해제 시점은 예측할 수 없다.

- **4.7 식별자 네이밍 규칙**  
  - 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($) 포함 가능
  - 숫자로 시작하는 것은 허용되지 않음
  - 예약어는 식별자로 사용할 수 없음(키워드)
  - 알파벳 외의 유니코드 문자(한글, 일본어 등)은 권장되지 않음
  - 대소문자를 구별함
  - 변수나 함수는 카멜 케이스를, 생성자 함수나 클래스는 파스칼 케이스를 사용
 

# 5장 표현식과 문
- **5.1 값**
  표현식이 평가되어 생성된 결과
  
- **5.2 리터럴**
  사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
  
- **5.3 표현식**  
  값으로 평가될 수 있는 문. 리터럴도 표현식이고, 변수 식별자를 참조해도 표현식이다. 값으로 평가될 수 있다면 모두 표현식이다.
  
- **5.4 문**  
  프로그램을 구성하는 기본 단위이자 최소 실행 단어이다. 문은 여러 토큰으로 구성되는데 토큰이란 문법적 의미를 가지며 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.
  ```
  var sum = 1 + 2;
  ```
  에서 `var`, `sum`, `=`, `1`, `+`, `2`은 각각 하나의 토큰이다.

- **5.5 세미콜론과 세미콜론 자동 삽입 기능**  
  자바스크립트는 기본적으로 세미콜론이 자동적으로 삽입되지만 예외는 당연히 있기 때문에 세미콜론을 붙이는 것이 권장된다.

- **5.6 표현식인 문과 표현식이 아닌 문**  
  이 둘을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.
  ```
  var foo = var x; //SyntaxErrorL Uexpected token var
  // 표현식이 아닌 문인 선언문은 값처럼 사용할 수 없다.
  ```
  크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하는데 이를 완료 값이라고 한다. 표현식인 문을 실행하면 평가된 값을 반환한다.
